// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"
	"nft.house/service/db_models"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newUrlEntry(db *gorm.DB, opts ...gen.DOOption) urlEntry {
	_urlEntry := urlEntry{}

	_urlEntry.urlEntryDo.UseDB(db, opts...)
	_urlEntry.urlEntryDo.UseModel(&db_models.UrlEntry{})

	tableName := _urlEntry.urlEntryDo.TableName()
	_urlEntry.ALL = field.NewAsterisk(tableName)
	_urlEntry.Id = field.NewInt64(tableName, "id")
	_urlEntry.MigrationId = field.NewInt64(tableName, "migration_id")
	_urlEntry.Url = field.NewString(tableName, "url")
	_urlEntry.LocalName = field.NewString(tableName, "local_name")
	_urlEntry.CreatedAt = field.NewTime(tableName, "created_at")

	_urlEntry.fillFieldMap()

	return _urlEntry
}

type urlEntry struct {
	urlEntryDo

	ALL         field.Asterisk
	Id          field.Int64
	MigrationId field.Int64
	Url         field.String
	LocalName   field.String
	CreatedAt   field.Time

	fieldMap map[string]field.Expr
}

func (u urlEntry) Table(newTableName string) *urlEntry {
	u.urlEntryDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u urlEntry) As(alias string) *urlEntry {
	u.urlEntryDo.DO = *(u.urlEntryDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *urlEntry) updateTableName(table string) *urlEntry {
	u.ALL = field.NewAsterisk(table)
	u.Id = field.NewInt64(table, "id")
	u.MigrationId = field.NewInt64(table, "migration_id")
	u.Url = field.NewString(table, "url")
	u.LocalName = field.NewString(table, "local_name")
	u.CreatedAt = field.NewTime(table, "created_at")

	u.fillFieldMap()

	return u
}

func (u *urlEntry) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *urlEntry) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 5)
	u.fieldMap["id"] = u.Id
	u.fieldMap["migration_id"] = u.MigrationId
	u.fieldMap["url"] = u.Url
	u.fieldMap["local_name"] = u.LocalName
	u.fieldMap["created_at"] = u.CreatedAt
}

func (u urlEntry) clone(db *gorm.DB) urlEntry {
	u.urlEntryDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u urlEntry) replaceDB(db *gorm.DB) urlEntry {
	u.urlEntryDo.ReplaceDB(db)
	return u
}

type urlEntryDo struct{ gen.DO }

type IUrlEntryDo interface {
	gen.SubQuery
	Debug() IUrlEntryDo
	WithContext(ctx context.Context) IUrlEntryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUrlEntryDo
	WriteDB() IUrlEntryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUrlEntryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUrlEntryDo
	Not(conds ...gen.Condition) IUrlEntryDo
	Or(conds ...gen.Condition) IUrlEntryDo
	Select(conds ...field.Expr) IUrlEntryDo
	Where(conds ...gen.Condition) IUrlEntryDo
	Order(conds ...field.Expr) IUrlEntryDo
	Distinct(cols ...field.Expr) IUrlEntryDo
	Omit(cols ...field.Expr) IUrlEntryDo
	Join(table schema.Tabler, on ...field.Expr) IUrlEntryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUrlEntryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUrlEntryDo
	Group(cols ...field.Expr) IUrlEntryDo
	Having(conds ...gen.Condition) IUrlEntryDo
	Limit(limit int) IUrlEntryDo
	Offset(offset int) IUrlEntryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUrlEntryDo
	Unscoped() IUrlEntryDo
	Create(values ...*db_models.UrlEntry) error
	CreateInBatches(values []*db_models.UrlEntry, batchSize int) error
	Save(values ...*db_models.UrlEntry) error
	First() (*db_models.UrlEntry, error)
	Take() (*db_models.UrlEntry, error)
	Last() (*db_models.UrlEntry, error)
	Find() ([]*db_models.UrlEntry, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*db_models.UrlEntry, err error)
	FindInBatches(result *[]*db_models.UrlEntry, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*db_models.UrlEntry) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUrlEntryDo
	Assign(attrs ...field.AssignExpr) IUrlEntryDo
	Joins(fields ...field.RelationField) IUrlEntryDo
	Preload(fields ...field.RelationField) IUrlEntryDo
	FirstOrInit() (*db_models.UrlEntry, error)
	FirstOrCreate() (*db_models.UrlEntry, error)
	FindByPage(offset int, limit int) (result []*db_models.UrlEntry, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUrlEntryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u urlEntryDo) Debug() IUrlEntryDo {
	return u.withDO(u.DO.Debug())
}

func (u urlEntryDo) WithContext(ctx context.Context) IUrlEntryDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u urlEntryDo) ReadDB() IUrlEntryDo {
	return u.Clauses(dbresolver.Read)
}

func (u urlEntryDo) WriteDB() IUrlEntryDo {
	return u.Clauses(dbresolver.Write)
}

func (u urlEntryDo) Session(config *gorm.Session) IUrlEntryDo {
	return u.withDO(u.DO.Session(config))
}

func (u urlEntryDo) Clauses(conds ...clause.Expression) IUrlEntryDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u urlEntryDo) Returning(value interface{}, columns ...string) IUrlEntryDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u urlEntryDo) Not(conds ...gen.Condition) IUrlEntryDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u urlEntryDo) Or(conds ...gen.Condition) IUrlEntryDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u urlEntryDo) Select(conds ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u urlEntryDo) Where(conds ...gen.Condition) IUrlEntryDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u urlEntryDo) Order(conds ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u urlEntryDo) Distinct(cols ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u urlEntryDo) Omit(cols ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u urlEntryDo) Join(table schema.Tabler, on ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u urlEntryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u urlEntryDo) RightJoin(table schema.Tabler, on ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u urlEntryDo) Group(cols ...field.Expr) IUrlEntryDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u urlEntryDo) Having(conds ...gen.Condition) IUrlEntryDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u urlEntryDo) Limit(limit int) IUrlEntryDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u urlEntryDo) Offset(offset int) IUrlEntryDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u urlEntryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUrlEntryDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u urlEntryDo) Unscoped() IUrlEntryDo {
	return u.withDO(u.DO.Unscoped())
}

func (u urlEntryDo) Create(values ...*db_models.UrlEntry) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u urlEntryDo) CreateInBatches(values []*db_models.UrlEntry, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u urlEntryDo) Save(values ...*db_models.UrlEntry) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u urlEntryDo) First() (*db_models.UrlEntry, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*db_models.UrlEntry), nil
	}
}

func (u urlEntryDo) Take() (*db_models.UrlEntry, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*db_models.UrlEntry), nil
	}
}

func (u urlEntryDo) Last() (*db_models.UrlEntry, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*db_models.UrlEntry), nil
	}
}

func (u urlEntryDo) Find() ([]*db_models.UrlEntry, error) {
	result, err := u.DO.Find()
	return result.([]*db_models.UrlEntry), err
}

func (u urlEntryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*db_models.UrlEntry, err error) {
	buf := make([]*db_models.UrlEntry, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u urlEntryDo) FindInBatches(result *[]*db_models.UrlEntry, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u urlEntryDo) Attrs(attrs ...field.AssignExpr) IUrlEntryDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u urlEntryDo) Assign(attrs ...field.AssignExpr) IUrlEntryDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u urlEntryDo) Joins(fields ...field.RelationField) IUrlEntryDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u urlEntryDo) Preload(fields ...field.RelationField) IUrlEntryDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u urlEntryDo) FirstOrInit() (*db_models.UrlEntry, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*db_models.UrlEntry), nil
	}
}

func (u urlEntryDo) FirstOrCreate() (*db_models.UrlEntry, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*db_models.UrlEntry), nil
	}
}

func (u urlEntryDo) FindByPage(offset int, limit int) (result []*db_models.UrlEntry, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u urlEntryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u urlEntryDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u urlEntryDo) Delete(models ...*db_models.UrlEntry) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *urlEntryDo) withDO(do gen.Dao) *urlEntryDo {
	u.DO = *do.(*gen.DO)
	return u
}
